# 1 "main.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "main.c"
# 35 "main.c"
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 1 3
# 10 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/ieeefp.h" 1 3
# 11 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 1 3
# 15 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/newlib.h" 1 3
# 16 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/config.h" 1 3



# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/ieeefp.h" 1 3
# 5 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/config.h" 2 3
# 17 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 2 3
# 12 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3



# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 211 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 323 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 16 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3

# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 1 3
# 13 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 1 3
# 14 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 1 3
# 12 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_types.h" 1 3






# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 1 3
# 26 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 8 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_types.h" 2 3
# 13 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 14 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3


typedef long _off_t;







typedef int __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;







typedef long _fpos_t;
# 56 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 3
typedef int _ssize_t;






# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 352 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 64 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 89 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 105 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 169 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                     ;
  int (* _write) (struct _reent *, void *, const char *, int)
                            ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  int _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 273 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 305 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 579 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  struct _atexit *_atexit;
  struct _atexit _atexit0;


  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 817 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);
# 18 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/stdlib.h" 1 3
# 19 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 27 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3


typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;
# 58 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
extern int __mb_cur_max;



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);



int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *))



                                                         ;
void * calloc (size_t __nmemb, size_t __size) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *) ;
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);
long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) ;
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);
# 111 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));
int rand (void);
void * realloc (void * __r, size_t __size) ;



void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
double _strtod_r (struct _reent *,const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);






long strtol (const char *__n, char **__end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__n, char **__end_PTR, int __base);

int system (const char *__string);
# 198 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);



extern long double strtold (const char *, char **);
extern long double wcstold (const wchar_t *, wchar_t **);



# 36 "main.c" 2
# 1 "main.h" 1







int main();
void hideSprites();
void init1();
void init2();
void init3();
void update1();
void update2();
void update3();
void updateOAM1();
void updateOAM2();
void updateOAM3();
void spawnEnemy1();
void spawnEnemy1Flip();
void spawnEnemy2();
void spawnEnemy2Flip();
void spawnEnemy3();
void spawnEnemy4();
void spawnParachute();
void enemy1PlayerCollisionCheck();
void enemy1FlipPlayerCollisionCheck();
void enemy2PlayerCollisionCheck();
void enemy2FlipPlayerCollisionCheck();
void enemy3PlayerCollisionCheck();
void enemy4PlayerCollisionCheck();
void parachutePlayerCollisionCheck();

void goToSplash();
void goToL1Instructs();
void goToLevel1();
void goToL2Instructs();
void goToLevel2();
void goToL3Instructs();
void goToLevel3();
void goToPause1();
void goToPause2();
void goToPause3();
void goToWin();
void goToLose1();
void goToLose2();
void goToLose3();
void updateSplash();
void updateL1Instructs();
void updateLevel1();
void updateL2Instructs();
void updateLevel2();
void updateL3Instructs();
void updateLevel3();
void updatePause1();
void updatePause2();
void updatePause3();
void updateWin();
void updateLose1();
void updateLose2();
void updateLose3();
void updateFinalCutScene();

void setupSounds();
void playSoundA( const unsigned char* sound, int length, int frequency, int loops);
void playSoundB( const unsigned char* sound, int length, int frequency, int loops);
void muteSound();
void pauseSound();
void unpauseSound();
void unmuteSound();
void stopSound();
void setupInterrupts();
void interruptHandler();

typedef struct {
 int row, oldRow;
 int col, oldCol;
 int height;
 int width;
 int rd;
 int cd;
 int punching;
 int flipped;
 int stamina;
}PLAYER;

typedef struct {
 int row, oldRow;
 int col, oldCol;
 int height;
 int width;
 int rd;
 int cd;
 int active;
 int dead;
 int colliding;
}ENEMIES;

typedef struct {
 int row, oldRow;
 int col, oldCol;
 int height;
 int width;
 int rd;
 int cd;
 int active;
}PARACHUTE;

typedef struct {
 int row, col;
}GAMEBARS;

typedef struct{
    const unsigned char* data;
    int length;
    int frequency;
    int isPlaying;
    int loops;
    int duration;
    int priority;
    int vbCount;
}SOUND;
# 37 "main.c" 2
# 1 "myLib.h" 1



typedef unsigned short u16;
# 40 "myLib.h"
extern unsigned short *videoBuffer;

extern unsigned short *frontBuffer;
extern unsigned short *backBuffer;



void loadPalette(const unsigned short* palette);
void initialize();

void waitForVblank();
void flipPage();
# 72 "myLib.h"
extern unsigned int oldButtons;
extern unsigned int buttons;
# 82 "myLib.h"
void DMANow(int channel, volatile const void* source, volatile void* destination, unsigned int control);






typedef volatile struct
{
        volatile const void *src;
        volatile void *dst;
        volatile unsigned int cnt;
} DMA;

extern DMA *dma;
# 211 "myLib.h"
typedef struct { u16 tileimg[8192]; } charblock;
typedef struct { u16 tilemap[1024]; } screenblock;
# 268 "myLib.h"
typedef struct{
    unsigned short attr0;
    unsigned short attr1;
    unsigned short attr2;
    unsigned short fill;
}OBJ_ATTR;

typedef struct {
    int row;
    int col;
} Sprite;
# 38 "main.c" 2
# 1 "game.h" 1


void updatePlayer(PLAYER* p);
void updateEnemy1(ENEMIES* e);
void updateEnemy1Flip(ENEMIES* e1f);
void updateEnemy2(ENEMIES* e2);
void updateEnemy2Flip(ENEMIES* e2f);
void updateEnemy3(ENEMIES* e3);
void updateEnemy4(ENEMIES* e4);
void updateParachute(PARACHUTE* ch);
# 39 "main.c" 2
# 1 "sprite.h" 1
# 21 "sprite.h"
extern const unsigned short spriteTiles[16384];


extern const unsigned short spritePal[256];
# 40 "main.c" 2
# 1 "splash.h" 1
# 22 "splash.h"
extern const unsigned short splashTiles[1360];


extern const unsigned short splashMap[1024];


extern const unsigned short splashPal[256];
# 41 "main.c" 2
# 1 "l1instructs.h" 1
# 22 "l1instructs.h"
extern const unsigned short l1instructsTiles[8256];


extern const unsigned short l1instructsMap[1024];


extern const unsigned short l1instructsPal[256];
# 42 "main.c" 2
# 1 "level1_bg.h" 1
# 22 "level1_bg.h"
extern const unsigned short level1_bgTiles[8240];


extern const unsigned short level1_bgMap[1024];


extern const unsigned short level1_bgPal[256];
# 43 "main.c" 2
# 1 "level2_bg.h" 1
# 22 "level2_bg.h"
extern const unsigned short level2_bgTiles[8528];


extern const unsigned short level2_bgMap[1024];


extern const unsigned short level2_bgPal[256];
# 44 "main.c" 2
# 1 "level3_bg.h" 1
# 22 "level3_bg.h"
extern const unsigned short level3_bgTiles[6640];


extern const unsigned short level3_bgMap[1024];


extern const unsigned short level3_bgPal[256];
# 45 "main.c" 2
# 1 "pause.h" 1
# 22 "pause.h"
extern const unsigned short pauseTiles[896];


extern const unsigned short pauseMap[1024];


extern const unsigned short pausePal[256];
# 46 "main.c" 2
# 1 "win.h" 1
# 22 "win.h"
extern const unsigned short winTiles[1360];


extern const unsigned short winMap[1024];


extern const unsigned short winPal[256];
# 47 "main.c" 2
# 1 "lose1.h" 1
# 22 "lose1.h"
extern const unsigned short lose1Tiles[1536];


extern const unsigned short lose1Map[1024];


extern const unsigned short lose1Pal[256];
# 48 "main.c" 2
# 1 "lose2_3.h" 1
# 22 "lose2_3.h"
extern const unsigned short lose2_3Tiles[1232];


extern const unsigned short lose2_3Map[1024];


extern const unsigned short lose2_3Pal[256];
# 49 "main.c" 2
# 1 "finalCutScene.h" 1
# 22 "finalCutScene.h"
extern const unsigned short finalCutSceneTiles[5472];


extern const unsigned short finalCutSceneMap[1024];


extern const unsigned short finalCutScenePal[256];
# 50 "main.c" 2
# 1 "titleSong.h" 1
# 20 "titleSong.h"
extern const unsigned char titleSong[498251];
# 51 "main.c" 2
# 1 "gameSound.h" 1
# 20 "gameSound.h"
extern const unsigned char gameSound[332090];
# 52 "main.c" 2
# 1 "gameSound0.h" 1
# 20 "gameSound0.h"
extern const unsigned char gameSound0[319392];
# 53 "main.c" 2
# 1 "oofSound.h" 1
# 20 "oofSound.h"
extern const unsigned char oofSound[6632];
# 54 "main.c" 2
# 1 "punching.h" 1
# 20 "punching.h"
extern const unsigned char punching[4251];
# 55 "main.c" 2
# 1 "farIsland.h" 1
# 22 "farIsland.h"
extern const unsigned short farIslandTiles[5136];


extern const unsigned short farIslandMap[2048];


extern const unsigned short farIslandPal[256];
# 56 "main.c" 2
# 1 "palmTrees.h" 1
# 22 "palmTrees.h"
extern const unsigned short palmTreesTiles[7280];


extern const unsigned short palmTreesMap[1024];


extern const unsigned short palmTreesPal[256];
# 57 "main.c" 2
# 1 "titleScreen.h" 1
# 22 "titleScreen.h"
extern const unsigned short titleScreenTiles[6464];


extern const unsigned short titleScreenMap[1024];


extern const unsigned short titleScreenPal[256];
# 58 "main.c" 2

unsigned int buttons;
unsigned int oldButtons;

unsigned short scanLineCounter;
char fpsbuffer[30];

int hOff;
int vOff;

OBJ_ATTR shadowOAM[128];

SOUND soundA;
SOUND soundB;




PLAYER player;



GAMEBARS health;

GAMEBARS stamina;

GAMEBARS enemDead;

ENEMIES enemies1[5];
int enemy1Count;
int timeToNxtEnemy1;
int enemy1Timer;

ENEMIES enemies1Flip[5];
int enemy1FlipCount;
int timeToNxtEnemy1Flip;
int enemy1FlipTimer;

ENEMIES enemies2[5];
int enemy2Count;
int timeToNxtEnemy2;
int enemy2Timer;

ENEMIES enemies2Flip[5];
int enemy2FlipCount;
int timeToNxtEnemy2Flip;
int enemy2FlipTimer;

ENEMIES enemies3[5];
int enemy3Count;
int timeToNxtEnemy3;
int enemy3Timer;

ENEMIES enemies4[5];
int enemy4Count;
int timeToNxtEnemy4;
int enemy4Timer;

PARACHUTE parachute[3];
int parachuteCount;
int timeToNxtChute;
int parachuteTimer;





void (*state)();
int playerHealth;
int enemiesDead;
int deadPuff;

int main() {

 hideSprites();
 goToSplash();


 setupSounds();
 setupInterrupts();

 while(1) {
  oldButtons = buttons;
  buttons = *(volatile unsigned int *)0x04000130;


  state();

  waitForVblank();
  }
 }

 void goToSplash() {
  state = updateSplash;


  hOff = 0;
  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;
  DMANow(3, titleScreenTiles, &((charblock *)0x6000000)[0], 12928 / 2 );
     DMANow(3, titleScreenMap, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, titleScreenPal, ((u16 *)0x5000000), 256);


     playSoundA(titleSong,498251,11025, 1);
 }

 void updateSplash() {
  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToL1Instructs();
  }

  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   goToLevel1();
   playSoundA(gameSound0,319392,11025, 1);
   hideSprites();
   init1();
  }
 }



 void goToL1Instructs() {
  state = updateL1Instructs;

  hOff = 0;
  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;
  DMANow(3, l1instructsTiles, &((charblock *)0x6000000)[0], 16512 / 2 );
     DMANow(3, l1instructsMap, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, l1instructsPal, ((u16 *)0x5000000), 256);
 }

 void updateL1Instructs() {
  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToSplash();
  }

  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   goToLevel1();
   playSoundA(gameSound0,319392,11025, 1);
   hideSprites();
   init1();
  }
 }

  void goToL2Instructs() {
  state = updateL2Instructs;

  hOff = 0;
  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;
  DMANow(3, level2_bgTiles, &((charblock *)0x6000000)[0], 17056 / 2 );
     DMANow(3, level2_bgMap, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, level2_bgPal, ((u16 *)0x5000000), 256);
     stopSound();
 }

 void updateL2Instructs() {
  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToSplash();
  }

  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   goToLevel2();
   playSoundA(gameSound,332090,11025, 1);
   hideSprites();
   init2();
  }
 }

  void goToL3Instructs() {
  state = updateL3Instructs;

  hOff = 0;
  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;
  DMANow(3, level3_bgTiles, &((charblock *)0x6000000)[0], 13280 / 2 );
     DMANow(3, level3_bgMap, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, level3_bgPal, ((u16 *)0x5000000), 256);
     stopSound();
 }

 void updateL3Instructs() {
  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToSplash();
  }

  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   goToLevel3();
   playSoundA(gameSound,332090,11025, 1);
   hideSprites();
   init3();
  }
 }







  void goToLevel1() {
  state = updateLevel1;


  *(unsigned short *)0x4000000 = 0 | (1<<8) | (1 << 12);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;


     loadPalette(level1_bgPal);


  DMANow(3, level1_bgTiles, &((charblock *)0x6000000)[0], 16480 /2);
  DMANow(3, level1_bgMap, &((screenblock *)0x6000000)[30], 2048 /2);


     DMANow(3, spriteTiles, &((charblock *)0x6000000)[4], 32768 / 2 );
     DMANow(3, spritePal, ((unsigned short*)(0x5000200)), 256);
 }

 void updateLevel1() {
 waitForVblank();
 update1();

  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   pauseSound();
   goToPause1();
  }

  if((!(~(oldButtons)&((1<<1))) && (~buttons & ((1<<1))))) {
   playerHealth = 1000000;
  }


        *(volatile unsigned short *)0x04000012 = vOff++ * 2;
        updateOAM1();
        DMANow(3, shadowOAM, ((OBJ_ATTR*)(0x7000000)), (128*4));
}

 void goToLevel2() {
  state = updateLevel2;


  *(unsigned short *)0x4000000 = 0 | (1<<8) | (1<<9) | (1<<10) | (1 << 12);
  *(volatile unsigned short*)0x4000008 = 1<<14 | 0 << 2 | 30 << 8;
  *(volatile unsigned short*)0x400000A = 0<<14 | 1 << 2 | 29 << 8;


     loadPalette(farIslandPal);


  DMANow(3, farIslandTiles, &((charblock *)0x6000000)[0], 10272 /2);
  DMANow(3, farIslandMap, &((screenblock *)0x6000000)[30], 4096 /2);
  DMANow(3, palmTreesTiles, &((charblock *)0x6000000)[1], 14560 /2);
  DMANow(3, palmTreesMap, &((screenblock *)0x6000000)[29], 2048 /2);


     DMANow(3, spriteTiles, &((charblock *)0x6000000)[4], 32768 / 2 );
     DMANow(3, spritePal, ((unsigned short*)(0x5000200)), 256);
 }

 void updateLevel2() {
 waitForVblank();
 update2();


  if((~(*(volatile unsigned int *)0x04000130) & ((1<<5))))
  {
   hOff--;
  }
  if((~(*(volatile unsigned int *)0x04000130) & ((1<<4))))
  {
   hOff++;
  }

  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   pauseSound();
   goToPause2();
  }

  if((!(~(oldButtons)&((1<<1))) && (~buttons & ((1<<1))))) {
   playerHealth = 1000000;
  }

  if((~(*(volatile unsigned int *)0x04000130) & ((1<<0)))) {

   playSoundB(punching, 4230, 11025, 0);


   if(player.stamina > 0) {
    player.punching = 1;
    player.stamina--;
   } else {

    player.punching = 0;
   }
  }

  else {

   player.punching = 0;
   if(player.stamina < 100) {
    player.stamina++;
   }
  }

        *(volatile unsigned short *)0x04000010 = hOff/2;
  *(volatile unsigned short *)0x04000014 = hOff/3;
        updateOAM2();
        DMANow(3, shadowOAM, ((OBJ_ATTR*)(0x7000000)), (128*4));
 }

 void goToLevel3() {
  state = updateLevel3;


  *(unsigned short *)0x4000000 = 0 | (1<<8) | (1<<9) | (1<<10) | (1 << 12);
  *(volatile unsigned short*)0x4000008 = 1<<14 | 0 << 2 | 30 << 8;
  *(volatile unsigned short*)0x400000A = 0<<14 | 1 << 2 | 29 << 8;



     loadPalette(farIslandPal);


  DMANow(3, farIslandTiles, &((charblock *)0x6000000)[0], 10272 /2);
  DMANow(3, farIslandMap, &((screenblock *)0x6000000)[30], 4096 /2);
  DMANow(3, palmTreesTiles, &((charblock *)0x6000000)[1], 14560 /2);
  DMANow(3, palmTreesMap, &((screenblock *)0x6000000)[29], 2048 /2);


     DMANow(3, spriteTiles, &((charblock *)0x6000000)[4], 32768 / 2 );
     DMANow(3, spritePal, ((unsigned short*)(0x5000200)), 256);
 }

 void updateLevel3() {
 waitForVblank();
 update3();

  if((~(*(volatile unsigned int *)0x04000130) & ((1<<5))))
  {
   hOff--;
  }
  if((~(*(volatile unsigned int *)0x04000130) & ((1<<4))))
  {
   hOff++;
  }

  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   pauseSound();
   goToPause3();
  }

  if((!(~(oldButtons)&((1<<1))) && (~buttons & ((1<<1))))) {
   playerHealth = 1000000;
  }

  if((~(*(volatile unsigned int *)0x04000130) & ((1<<0)))) {

   playSoundB(punching, 4230, 11025, 0);


   if(player.stamina > 0) {
    player.punching = 1;
    player.stamina--;
   } else {

    player.punching = 0;
   }
  }

  else {

   player.punching = 0;
   if(player.stamina < 100) {
    player.stamina++;
   }
  }


        *(volatile unsigned short *)0x04000010 = hOff/2;
  *(volatile unsigned short *)0x04000014 = hOff/2;
        updateOAM3();
        DMANow(3, shadowOAM, ((OBJ_ATTR*)(0x7000000)), (128*4));
}






 void goToPause1() {
  state = updatePause1;

  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 1<<14 | 0 << 2 | 30 << 8;
  DMANow(3, pauseTiles, &((charblock *)0x6000000)[0], 1792 / 2 );
     DMANow(3, pauseMap, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, pausePal, ((u16 *)0x5000000), 256);
 }

 void updatePause1() {
  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   unpauseSound();
   goToLevel1();
  }

  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToLevel1();
   playSoundA(gameSound0,319392,11025, 1);
   hideSprites();
   init1();
  }
 }

 void goToPause2() {
  state = updatePause2;

  *(unsigned short *)0x4000000 = 0 | (1<<8);
  hOff = 0;
  *(volatile unsigned short*)0x4000008 = 1<<14 | 0 << 2 | 30 << 8;
  DMANow(3, pauseTiles, &((charblock *)0x6000000)[0], 1792 / 2 );
     DMANow(3, pauseMap, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, pausePal, ((u16 *)0x5000000), 256);
 }

 void updatePause2() {
  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   unpauseSound();
   goToLevel2();
  }

  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToLevel2();
   playSoundA(gameSound,332090,11025, 1);
   hideSprites();
   init2();
  }
 }

 void goToPause3() {
  state = updatePause3;

  hOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 1<<14 | 0 << 2 | 30 << 8;
  DMANow(3, pauseTiles, &((charblock *)0x6000000)[0], 1792 / 2 );
     DMANow(3, pauseMap, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, pausePal, ((u16 *)0x5000000), 256);
 }

 void updatePause3() {
  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   unpauseSound();
   goToLevel3();
  }

  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToLevel3();
   playSoundA(gameSound,332090,11025, 1);
   hideSprites();
   init3();
  }
 }


 void goToWin() {
  state = updateWin;

  hOff = 0;
  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;
  DMANow(3, winTiles, &((charblock *)0x6000000)[0], 2720 / 2 );
     DMANow(3, winMap, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, winPal, ((u16 *)0x5000000), 256);
 }

 void updateWin() {
  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   goToSplash();
  }

 }

 void goToLose1() {
  state = updateLose1;

  hOff = 0;
  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;
  DMANow(3, lose1Tiles, &((charblock *)0x6000000)[0], 3072 / 2 );
     DMANow(3, lose1Map, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, lose1Pal, ((u16 *)0x5000000), 256);
     stopSound();
 }

 void updateLose1() {
  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   goToSplash();
  }

  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToLevel1();
   playSoundA(gameSound0,319392,11025, 1);
   hideSprites();
   init1();
  }
 }

 void goToLose2() {
  state = updateLose2;

  hOff = 0;
  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;
  DMANow(3, lose2_3Tiles, &((charblock *)0x6000000)[0], 2464 / 2 );
     DMANow(3, lose2_3Map, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, lose2_3Pal, ((u16 *)0x5000000), 256);
     stopSound();
 }

 void updateLose2() {
  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   goToSplash();
  }

  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToLevel2();
   playSoundA(gameSound,332090,11025, 1);
   hideSprites();
   init2();
  }
 }

 void goToLose3() {
  state = updateLose3;

  hOff = 0;
  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;
  DMANow(3, lose2_3Tiles, &((charblock *)0x6000000)[0], 2464 / 2 );
     DMANow(3, lose2_3Map, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, lose2_3Pal, ((u16 *)0x5000000), 256);
     stopSound();
 }

 void updateLose3() {
  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   goToSplash();
  }

  if((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
   goToLevel3();
   playSoundA(gameSound,332090,11025, 1);
   hideSprites();
   init3();
  }
 }


 void goToFinalCutScene() {
  state = updateFinalCutScene;

  hOff = 0;
  vOff = 0;
  *(unsigned short *)0x4000000 = 0 | (1<<8);
  *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 30 << 8;
  DMANow(3, finalCutSceneTiles, &((charblock *)0x6000000)[0], 10944 / 2 );
     DMANow(3, finalCutSceneMap, &((screenblock *)0x6000000)[30], 2048 / 2);
     DMANow(3, finalCutScenePal, ((u16 *)0x5000000), 256);
     stopSound();
 }

 void updateFinalCutScene() {
  if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   goToWin();
  }
 }



 void init1() {

  playerHealth = 3;
  player.row = 20;
  player.col = 120;
  player.width = 15;
     player.height = 31;


     health.row = 3;
     health.col = 160;


     ENEMIES enemy3;
     enemy3.row = 0;
     enemy3.col = 0;
     enemy3.oldRow = 0;
     enemy3.oldCol = 0;
     enemy3.width = 23;
     enemy3.height = 23;
     enemy3.rd = -1;
     enemy3.cd = 0;
     enemy3.active = 0;
     enemy3Count = (sizeof(enemies3)/sizeof(enemies3[0]));

     for(int i = 0; i < enemy3Count; i++) {
      enemies3[i] = enemy3;
     }

     enemy3Timer = 0;



     PARACHUTE chute;
     chute.row = 0;
     chute.col = 0;
     chute.oldRow = 0;
     chute.oldCol = 0;
     chute.width = 16;
     chute.height = 16;
     chute.rd = -1;
     chute.cd = 0;
     chute.active = 0;
     parachuteCount = (sizeof(parachute)/sizeof(parachute[0]));

     for(int i = 0; i < parachuteCount; i++) {
      parachute[i] = chute;
     }

     parachuteTimer = 0;

 }


 void init2() {

  playerHealth = 3;
  player.row = 123;
  player.col = 120;
  player.width = 15;
     player.height = 31;
     player.punching = 0;
     player.flipped = 0;
     player.stamina = 100;


     health.row = 3;
     health.col = 160;


     stamina.row = 3;
     stamina.col = 200;


     enemDead.row = 3;
     enemDead.col = 40;


     enemiesDead = 0;
     ENEMIES enemy1;
     enemy1.row = 147;
     enemy1.col = 0;
     enemy1.oldRow = 0;
     enemy1.oldCol = 0;
     enemy1.width = 23;
     enemy1.height = 23;
     enemy1.cd = 1;
    enemy1.dead = -1;
    enemy1.colliding = 0;
     enemy1.active = 0;
     enemy1Count = (sizeof(enemies1)/sizeof(enemies1[0]));

     for(int i = 0; i < enemy1Count; i++) {
      enemies1[i] = enemy1;
     }
     enemy1Timer = 0;

  ENEMIES enemy1Flip;
     enemy1Flip.row = 150;
     enemy1Flip.col = 0;
     enemy1Flip.oldRow = 0;
     enemy1Flip.oldCol = 0;
     enemy1Flip.width = 23;
     enemy1Flip.height = 23;
     enemy1Flip.cd = -1;
     enemy1Flip.colliding = 0;
     enemy1Flip.active = 0;
     enemy1FlipCount = (sizeof(enemies1Flip)/sizeof(enemies1Flip[0]));

     for(int i = 0; i < enemy1FlipCount; i++) {
      enemies1Flip[i] = enemy1Flip;
     }
     enemy1FlipTimer = 0;


     if(enemiesDead == 5) {
   goToL3Instructs();
  }
 }




 void init3() {
  playerHealth = 3;

  player.row = 123;
  player.col = 120;
  player.width = 15;
     player.height = 31;
     player.punching = 0;
     player.flipped = 0;
     player.stamina = 100;


     health.row = 3;
     health.col = 160;


     stamina.row = 3;
     stamina.col = 200;


     enemDead.row = 3;
     enemDead.col = 40;


     enemiesDead = 0;
     ENEMIES enemy2;
     enemy2.row = 147;
     enemy2.col = 0;
     enemy2.oldRow = 0;
     enemy2.oldCol = 0;
     enemy2.width = 23;
     enemy2.height = 23;
     enemy2.cd = 1;
     enemy2.colliding = 0;
     enemy2.active = 0;
     enemy2Count = (sizeof(enemies2)/sizeof(enemies2[0]));

     for(int i = 0; i < enemy2Count; i++) {
      enemies2[i] = enemy2;
     }

     enemy2Timer = 0;


     ENEMIES enemy2Flip;
     enemy2Flip.row = 150;
     enemy2Flip.col = 0;
     enemy2Flip.oldRow = 0;
     enemy2Flip.oldCol = 0;
     enemy2Flip.width = 23;
     enemy2Flip.height = 23;
     enemy2Flip.cd = 1;
     enemy2Flip.colliding = 0;
     enemy2Flip.active = 0;
     enemy2FlipCount = (sizeof(enemies2Flip)/sizeof(enemies2Flip[0]));

     for(int i = 0; i < enemy2FlipCount; i++) {
      enemies2Flip[i] = enemy2Flip;
     }

     enemy2FlipTimer = 0;


     ENEMIES enemy4;
     enemy4.row = 1;
     enemy4.col = 0;
     enemy4.oldRow = 0;
     enemy4.oldCol = 0;
     enemy4.width = 16;
     enemy4.height = 16;
     enemy4.rd = 1;
     enemy4.cd = 0;
     enemy4.colliding = 0;
     enemy4.active = 0;
     enemy4Count = (sizeof(enemies4)/sizeof(enemies4[0]));

     for(int i = 0; i < enemy4Count; i++) {
      enemies4[i] = enemy4;
     }

     enemy4Timer = 0;

 }




 void hideSprites() {

  for(int i = 0; i < 128; i++) {
   shadowOAM[i].attr0 = (2 << 8);
  }
 }



 void update1() {
  updatePlayer(&player);



  if(!(++enemy3Timer % timeToNxtEnemy3)) {
   for(int i = 0; i < enemy3Count; i++) {
    ENEMIES * e3 = &enemies3[i];
    if(!e3->active) {
     e3->active = 1;
     e3->row = 161;
     e3->col = rand()%(240);
     e3->rd = -2;

     timeToNxtEnemy3 = rand() % 25 + 100;
     break;
    }
   }
  }

  for(int i = 0; i < enemy3Count; i++) {
   updateEnemy3(&enemies3[i]);
   enemy3PlayerCollisionCheck(&enemies3[i], &player);
  }



  if(!(++parachuteTimer % timeToNxtChute)) {
   for(int i = 0; i < parachuteCount; i++) {
    PARACHUTE * ch = &parachute[i];
    if(!ch->active) {
     ch->active = 1;
     ch->row = 161;
     ch->col = rand()%(240);
     ch->rd = -2;

     timeToNxtChute = 300;
     break;
    }
   }
  }

  for(int i = 0; i < parachuteCount; i++) {
   updateParachute(&parachute[i]);
   parachutePlayerCollisionCheck(&parachute[i], &player);
  }
 }

 void update2() {
  updatePlayer(&player);


  if(!(++enemy1Timer % timeToNxtEnemy1)) {
   for(int i = 0; i < enemy1Count; i++) {
    ENEMIES * e = &enemies1[i];
    if(!e->active) {
     e->active = 1;
     e->row = 125;
     e->col = -24;
     e->cd = 1;
     e->dead = -1;

     timeToNxtEnemy1 = 150;
     break;
    }
   }
  }

  for(int i = 0; i < enemy1Count; i++) {
   updateEnemy1(&enemies1[i]);
   enemy1PlayerCollisionCheck(&enemies1[i], &player);
  }



  if(!(++enemy1FlipTimer % timeToNxtEnemy1Flip)) {
   for(int i = 0; i < enemy1FlipCount; i++) {
    ENEMIES * e1f = &enemies1Flip[i];
    if(!e1f->active) {
     e1f->active = 1;
     e1f->row = 125;
     e1f->col = 241;
     e1f->cd = -1;

     timeToNxtEnemy1Flip = 200;
     break;
    }
   }
  }

  for(int i = 0; i < enemy1FlipCount; i++) {
   updateEnemy1Flip(&enemies1Flip[i]);
   enemy1FlipPlayerCollisionCheck(&enemies1Flip[i], &player);
  }
 }

 void update3() {
  updatePlayer(&player);


  if(!(++enemy2Timer % timeToNxtEnemy2)) {
   for(int i = 0; i < enemy2Count; i++) {
    ENEMIES * e2 = &enemies2[i];
    if(!e2->active) {
     e2->active = 1;
     e2->row = 125;
     e2->col = -24;
     e2->cd = 1;

     timeToNxtEnemy2 = 150;
     break;
    }
   }
  }

  for(int i = 0; i < enemy2Count; i++) {
   updateEnemy2(&enemies2[i]);
   enemy2PlayerCollisionCheck(&enemies2[i], &player);
  }



  if(!(++enemy2FlipTimer % timeToNxtEnemy2Flip)) {
   for(int i = 0; i < enemy2FlipCount; i++) {
    ENEMIES * e2f = &enemies2Flip[i];
    if(!e2f->active) {
     e2f->active = 1;
     e2f->row = 125;
     e2f->col = 241;
     e2f->cd = -1;

     timeToNxtEnemy2Flip = 200;
     break;
    }
   }
  }

  for(int i = 0; i < enemy2FlipCount; i++) {
   updateEnemy2Flip(&enemies2Flip[i]);
   enemy2FlipPlayerCollisionCheck(&enemies2Flip[i], &player);
  }



  if(!(++enemy4Timer % timeToNxtEnemy4)) {
   for(int i = 0; i < enemy4Count; i++) {
    ENEMIES * e4 = &enemies4[i];
    if(!e4->active) {
     e4->active = 1;
     e4->row = -e4->height;
     e4->col = rand() % (240);
     e4->rd = 1.5;

     timeToNxtEnemy4 = 250;
     break;
    }
   }
  }

  for(int i = 0; i < enemy4Count; i++) {
   updateEnemy4(&enemies4[i]);
   enemy4PlayerCollisionCheck(&enemies4[i], &player);
  }
 }





 void updateOAM1() {


  shadowOAM[0].attr0 = player.row | (2 << 14);


  if(player.flipped == 0) {
   shadowOAM[0].attr1 = (2 << 14)| (1 << 13) | player.col;
   shadowOAM[0].attr2 = (0)*32+(22);
  }

  else if(player.flipped == 1) {
   shadowOAM[0].attr1 = (2 << 14) | (1 << 12) | (1 << 13)| player.col;
   shadowOAM[0].attr2 = (0)*32+(22);
  }

  spawnEnemy3();

  spawnParachute();

  if(playerHealth == 3) {
   shadowOAM[12].attr0 = health.row | (1 << 14);
   shadowOAM[12].attr1 = (1 << 14) | health.col;
   shadowOAM[12].attr2 = (0)*32+(24);
  } else if(playerHealth == 2) {
   shadowOAM[12].attr0 = health.row | (1 << 14);
   shadowOAM[12].attr1 = (0 << 14) | health.col;
   shadowOAM[12].attr2 = (0)*32+(28);
  } else if(playerHealth == 1) {
   shadowOAM[12].attr0 = health.row | (0 << 14);
   shadowOAM[12].attr1 = (0 << 14) | health.col;
   shadowOAM[12].attr2 = (0)*32+(31);
  } else if(playerHealth == 1000000) {
   shadowOAM[12].attr0 = health.row | (1 << 14);
   shadowOAM[12].attr1 = (3 << 14) | health.col;
   shadowOAM[12].attr2 = (1)*32+(24);
  }
 }


 void updateOAM2() {


  shadowOAM[0].attr0 = player.row | (2 << 14);


  if(player.punching == 0 && player.flipped == 0) {
   shadowOAM[0].attr1 = (2 << 14)| player.col;
   shadowOAM[0].attr2 = (0)*32+(0);
  }

  else if(player.punching == 0 && player.flipped == 1) {
   shadowOAM[0].attr1 = (2 << 14) | (1 << 12) | player.col;
   shadowOAM[0].attr2 = (0)*32+(0);
  }

  else if(player.punching == 1 && player.flipped == 0) {
   shadowOAM[0].attr2 = (0)*32+(2);
  }

  else if(player.punching == 1 && player.flipped == 1) {
   shadowOAM[0].attr1 = (2 << 14) | (1 << 12) | player.col;
   shadowOAM[0].attr2 = (0)*32+(2);
  }



  spawnEnemy1();
  spawnEnemy1Flip();



  if(playerHealth == 3) {
   shadowOAM[12].attr0 = health.row | (1 << 14);
   shadowOAM[12].attr1 = (1 << 14) | health.col;
   shadowOAM[12].attr2 = (0)*32+(24);
  } else if(playerHealth == 2) {
   shadowOAM[12].attr0 = health.row | (1 << 14);
   shadowOAM[12].attr1 = (0 << 14) | health.col;
   shadowOAM[12].attr2 = (0)*32+(28);
  } else if(playerHealth == 1) {
   shadowOAM[12].attr0 = health.row | (0 << 14);
   shadowOAM[12].attr1 = (0 << 14) | health.col;
   shadowOAM[12].attr2 = (0)*32+(31);
  } else if(playerHealth == 1000000) {
   shadowOAM[12].attr0 = health.row | (1 << 14);
   shadowOAM[12].attr1 = (3 << 14) | health.col;
   shadowOAM[12].attr2 = (1)*32+(24);
  }


  if(player.stamina == 100) {
   shadowOAM[13].attr0 = stamina.row | (1 << 14);
   shadowOAM[13].attr1 = (1 << 14) | stamina.col;
   shadowOAM[13].attr2 = (8)*32+(0);
  } else if(player.stamina == 75) {
   shadowOAM[13].attr0 = stamina.row | (1 << 14);
   shadowOAM[13].attr1 = (1 << 14) | stamina.col;
   shadowOAM[13].attr2 = (9)*32+(0);
  } else if(player.stamina == 50) {
   shadowOAM[13].attr0 = stamina.row | (1 << 14);
   shadowOAM[13].attr1 = (1 << 14) | stamina.col;
   shadowOAM[13].attr2 = (10)*32+(0);
  } else if(player.stamina == 25) {
   shadowOAM[13].attr0 = stamina.row | (1 << 14);
   shadowOAM[13].attr1 = (1 << 14) | stamina.col;
   shadowOAM[13].attr2 = (11)*32+(0);
  } else if(player.stamina == 0) {
   shadowOAM[13].attr0 = stamina.row | (1 << 14);
   shadowOAM[13].attr1 = (1 << 14) | stamina.col;
   shadowOAM[13].attr2 = (8)*32+(4);
  }


  if(enemiesDead == 0) {
   shadowOAM[14].attr0 = enemDead.row | (0 << 14);
   shadowOAM[14].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[14].attr2 = (8)*32+(12);
  } else if(enemiesDead == 1) {
   shadowOAM[14].attr0 = enemDead.row | (0 << 14);
   shadowOAM[14].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[14].attr2 = (8)*32+(13);
  } else if(enemiesDead == 2) {
   shadowOAM[14].attr0 = enemDead.row | (0 << 14);
   shadowOAM[14].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[14].attr2 = (8)*32+(14);
  } else if(enemiesDead == 3) {
   shadowOAM[14].attr0 = enemDead.row | (0 << 14);
   shadowOAM[14].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[14].attr2 = (8)*32+(15);
  } else if(enemiesDead == 4) {
   shadowOAM[14].attr0 = enemDead.row | (0 << 14);
   shadowOAM[14].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[14].attr2 = (8)*32+(16);
  }
 }

 void updateOAM3() {


  shadowOAM[0].attr0 = player.row | (2 << 14);


  if(player.punching == 0 && player.flipped == 0) {
   shadowOAM[0].attr1 = (2 << 14)| player.col;
   shadowOAM[0].attr2 = (0)*32+(0);
  }

  else if(player.punching == 0 && player.flipped == 1) {
   shadowOAM[0].attr1 = (2 << 14) | (1 << 12) | player.col;
   shadowOAM[0].attr2 = (0)*32+(0);
  }

  else if(player.punching == 1 && player.flipped == 0) {
   shadowOAM[0].attr2 = (0)*32+(2);
  }

  else if(player.punching == 1 && player.flipped == 1) {
   shadowOAM[0].attr1 = (2 << 14) | (1 << 12) | player.col;
   shadowOAM[0].attr2 = (0)*32+(2);
  }


   spawnEnemy2();
   spawnEnemy2Flip();
   spawnEnemy4();



  if(playerHealth == 3) {
   shadowOAM[16].attr0 = health.row | (1 << 14);
   shadowOAM[16].attr1 = (1 << 14) | health.col;
   shadowOAM[16].attr2 = (0)*32+(24);
  } else if(playerHealth == 2) {
   shadowOAM[16].attr0 = health.row | (1 << 14);
   shadowOAM[16].attr1 = (0 << 14) | health.col;
   shadowOAM[16].attr2 = (0)*32+(28);
  } else if(playerHealth == 1) {
   shadowOAM[16].attr0 = health.row | (0 << 14);
   shadowOAM[16].attr1 = (0 << 14) | health.col;
   shadowOAM[16].attr2 = (0)*32+(31);
  } else if(playerHealth == 1000000) {
   shadowOAM[16].attr0 = health.row | (1 << 14);
   shadowOAM[16].attr1 = (3 << 14) | health.col;
   shadowOAM[16].attr2 = (1)*32+(24);
  }



  if(player.stamina == 100) {
   shadowOAM[17].attr0 = stamina.row | (1 << 14);
   shadowOAM[17].attr1 = (1 << 14) | stamina.col;
   shadowOAM[17].attr2 = (8)*32+(0);
  } else if(player.stamina == 75) {
   shadowOAM[17].attr0 = stamina.row | (1 << 14);
   shadowOAM[17].attr1 = (1 << 14) | stamina.col;
   shadowOAM[17].attr2 = (9)*32+(0);
  } else if(player.stamina == 50) {
   shadowOAM[17].attr0 = stamina.row | (1 << 14);
   shadowOAM[17].attr1 = (1 << 14) | stamina.col;
   shadowOAM[17].attr2 = (10)*32+(0);
  } else if(player.stamina == 25) {
   shadowOAM[17].attr0 = stamina.row | (1 << 14);
   shadowOAM[17].attr1 = (1 << 14) | stamina.col;
   shadowOAM[17].attr2 = (11)*32+(0);
  } else if(player.stamina == 0) {
   shadowOAM[17].attr0 = stamina.row | (1 << 14);
   shadowOAM[17].attr1 = (1 << 14) | stamina.col;
   shadowOAM[17].attr2 = (8)*32+(4);
  }



  if(enemiesDead == 0) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(12);
  } else if(enemiesDead == 1) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(13);
  } else if(enemiesDead == 2) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(14);
  } else if(enemiesDead == 3) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(15);
  } else if(enemiesDead == 4) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(16);
  } else if(enemiesDead == 5) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(17);
  } else if(enemiesDead == 6) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(18);
  } else if(enemiesDead == 7) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(19);
  } else if(enemiesDead == 8) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(20);
  } else if(enemiesDead == 9) {
   shadowOAM[18].attr0 = enemDead.row | (0 << 14);
   shadowOAM[18].attr1 = (0 << 14) | enemDead.col;
   shadowOAM[18].attr2 = (8)*32+(21);
  }
 }
# 1300 "main.c"
 void spawnEnemy1() {
  for (int i = 0; i < 5; i++) {
   if(enemies1[i].active) {
    shadowOAM[1+i].attr0 = (enemies1[i].row & 0XFF) | (0 << 14);
    shadowOAM[1+i].attr1 = (2 << 14) | (1 << 12) | (enemies1[i].col & 0XFF);
    shadowOAM[1+i].attr2 = (0)*32+(4);
   } else if (enemies1[i].dead > 0) {
    shadowOAM[1+i].attr0 = (enemies1[i].row & 0XFF) | (0 << 14);
    shadowOAM[1+i].attr1 = (2 << 14) | (enemies1[i].col & 0XFF);
    shadowOAM[1+i].attr2 = (8)*32+(8);
    enemies1[i].dead--;
   } else if(enemies1[i].dead == 0) {
    enemies1[i].active = 0;
    shadowOAM[1+i].attr0 = (2 << 8);
   }
  }
 }


 void spawnEnemy1Flip() {

  for (int i = 0; i < 5; i++) {
   if(enemies1Flip[i].active) {
    shadowOAM[6+i].attr0 = (enemies1Flip[i].row & 0XFF) | (0 << 14);
    shadowOAM[6+i].attr1 = (2 << 14) | (enemies1Flip[i].col & 0XFF);
    shadowOAM[6+i].attr2 = (0)*32+(4);
   } else if (enemies1Flip[i].dead > 0) {
    shadowOAM[6+i].attr0 = (enemies1Flip[i].row & 0XFF) | (0 << 14);
    shadowOAM[6+i].attr1 = (2 << 14) | (enemies1Flip[i].col & 0XFF);
    shadowOAM[6+i].attr2 = (8)*32+(8);
    enemies1Flip[i].dead--;
   } else if(enemies1Flip[i].dead == 0) {
    enemies1Flip[i].active = 0;
    shadowOAM[6+i].attr0 = (2 << 8);
   }

  }
 }


 void spawnEnemy2() {

  for (int i = 0; i < 5; i++) {
   if(enemies2[i].active) {
    shadowOAM[1+i].attr0 = (enemies2[i].row & 0XFF) | (0 << 14);
    shadowOAM[1+i].attr1 = (2 << 14) | (1 << 12) | (enemies2[i].col & 0XFF);
    shadowOAM[1+i].attr2 = (0)*32+(8);
   } else if (enemies2[i].dead > 0) {
    shadowOAM[1+i].attr0 = (enemies2[i].row & 0XFF) | (0 << 14);
    shadowOAM[1+i].attr1 = (2 << 14) | (enemies2[i].col & 0XFF);
    shadowOAM[1+i].attr2 = (8)*32+(8);
    enemies2[i].dead--;
   } else if(enemies2[i].dead == 0) {
    enemies2[i].active = 0;
    shadowOAM[1+i].attr0 = (2 << 8);
   }
  }
 }


 void spawnEnemy2Flip() {

  for (int i = 0; i < 5; i++) {
   if(enemies2Flip[i].active) {
    shadowOAM[6+i].attr0 = (enemies2Flip[i].row & 0XFF) | (0 << 14);
    shadowOAM[6+i].attr1 = (2 << 14) | (enemies2Flip[i].col & 0XFF);
    shadowOAM[6+i].attr2 = (0)*32+(8);
   } else if (enemies2Flip[i].dead > 0) {
    shadowOAM[6+i].attr0 = (enemies2Flip[i].row & 0XFF) | (0 << 14);
    shadowOAM[6+i].attr1 = (2 << 14) | (enemies2Flip[i].col & 0XFF);
    shadowOAM[6+i].attr2 = (8)*32+(8);
    enemies2Flip[i].dead--;
   } else if(enemies2Flip[i].dead == 0) {
    enemies2Flip[i].active = 0;
    shadowOAM[6+i].attr0 = (2 << 8);
   }
  }
 }


 void spawnEnemy3() {

  for (int i = 0; i < 5; i++) {
   if(enemies3[i].active) {
    shadowOAM[1+i].attr0 = enemies3[i].row | (0 << 14);
    shadowOAM[1+i].attr1 = (2 << 14) | enemies3[i].col;
    shadowOAM[1+i].attr2 = (0)*32+(16);
   }
  }
 }


 void spawnEnemy4() {

  for (int i = 0; i < 5; i++) {
   if(enemies4[i].active) {
    shadowOAM[11+i].attr0 = (enemies4[i].row & 0XFF) | (0 << 14);
    shadowOAM[11+i].attr1 = (1 << 14) | enemies4[i].col;
    shadowOAM[11+i].attr2 = (0)*32+(20);
   }
  }
 }

 void spawnParachute() {

  for (int i = 0; i < 3; i++) {
   if(parachute[i].active) {
    shadowOAM[11+i].attr0 = (parachute[i].row & 0XFF) | (0 << 14);
    shadowOAM[11+i].attr1 = (1 << 14) | parachute[i].col;
    shadowOAM[11+i].attr2 = (2)*32+(20);
   }
  }
 }






 void enemy1PlayerCollisionCheck(ENEMIES * e, PLAYER * p) {

  if(p->punching == 0 && p->flipped == 0) {
   if((e->active) && (e->col + e->width >= p->col) && (e->col <= p->col + p->width)) {
    if(e->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e->colliding = 1;
     e->cd = 2;
     playerHealth--;
    }
   } else {
    e->colliding = 0;
   }
  }

  if(p->punching == 0 && p->flipped == 1) {
   if((e->active) && (e->col + e->width >= p->col) && (e->col <= p->col + p->width)) {
    if(e->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e->colliding = 1;
     e->cd = 2;
     playerHealth--;
    }
   } else {
    e->colliding = 0;
   }
  }

  if(p->punching == 1 && p->flipped == 0) {
   if((e->active) && (e->col + e->width >= p->col) && (e->col <= p->col + p->width)) {
    if(e->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e->colliding = 1;
     e->cd = 2;
     playerHealth--;
    }
   } else {
    e->colliding = 0;
   }
  }



  if (p->punching == 1 && p->flipped == 1) {
   if((e->active) && (e->col + e->width >= p->col) && (e->col <= p->col + p->width)) {
    if(e->colliding == 0) {
    e->dead = 20;
    enemiesDead++;
    e->active = 0;
    e->colliding = 1;

    }
   } else {
    e->colliding = 0;
   }
  }

  if(playerHealth == 0) {
   goToLose2();
  }

  if(enemiesDead == 5) {
   goToL3Instructs();
  }
 }


 void enemy1FlipPlayerCollisionCheck(ENEMIES * e1f, PLAYER * p) {

  if(p->punching == 0 && p->flipped == 0) {
   if((e1f->active) && (e1f->col == p->col + p->width)) {
    if(e1f->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e1f->colliding = 1;
     e1f->cd = -2;
     playerHealth--;
    }
   } else {
    e1f->colliding = 0;
   }
  }

  if(p->punching == 0 && p->flipped == 1) {
   if((e1f->active) && (e1f->col == p->col + p->width)) {
    if(e1f->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e1f->colliding = 1;
     e1f->cd = -2;
     playerHealth--;
    }
   } else {
    e1f->colliding = 0;
   }
  }

  if(p->punching == 1 && p->flipped == 1) {
   if((e1f->active) && (e1f->col == p->col + p->width)) {
    if(e1f->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e1f->colliding = 1;
     e1f->cd = -2;
     playerHealth--;
    }
   } else {
    e1f->colliding = 0;
   }
  }

  if (p->punching == 1 && p->flipped == 0) {
    if((e1f->active) && (e1f->col == p->col + p->width)) {
     if(e1f->colliding == 0) {
      e1f->dead = 20;
      enemiesDead++;
      e1f->active = 0;
      e1f->colliding = 1;

     }
    } else {
     e1f->colliding = 0;
   }
  }

  if(playerHealth == 0) {
   goToLose2();
  }

  if(enemiesDead == 5) {
   goToL3Instructs();
  }
 }

 void enemy2PlayerCollisionCheck(ENEMIES * e2, PLAYER * p) {

  if(p->punching == 0 && p->flipped == 0) {
   if((e2->active) && (e2->col + e2->width >= p->col) && (e2->col <= p->col + p->width)) {
    if(e2->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e2->colliding = 1;
     e2->cd = 2;
     playerHealth--;
    }
   } else {
    e2->colliding = 0;
   }
  }

  if(p->punching == 0 && p->flipped == 1) {
   if((e2->active) && (e2->col + e2->width >= p->col) && (e2->col <= p->col + p->width)) {
    if(e2->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e2->colliding = 1;
     e2->cd = 2;
     playerHealth--;
    }
   } else {
    e2->colliding = 0;
   }
  }

  if(p->punching == 1 && p->flipped == 0) {
   if((e2->active) && (e2->col + e2->width >= p->col) && (e2->col <= p->col + p->width)) {
    if(e2->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e2->colliding = 1;
     e2->cd = 2;
     playerHealth--;
    }
   } else {
    e2->colliding = 0;
   }
  }



  if (p->punching == 1 && p->flipped == 1) {
   if((e2->active) && (e2->col + e2->width >= p->col) && (e2->col <= p->col + p->width)) {
    if(e2->colliding == 0) {
    e2->dead = 20;
    enemiesDead++;
    e2->active = 0;
    e2->colliding = 1;

    }
   } else {
    e2->colliding = 0;
   }
  }

  if(playerHealth == 0) {
   goToLose3();
  }

  if(enemiesDead == 10) {
   goToFinalCutScene();
  }
 }


 void enemy2FlipPlayerCollisionCheck(ENEMIES * e2f, PLAYER * p) {

  if(p->punching == 0 && p->flipped == 0) {
   if((e2f->active) && (e2f->col == p->col + p->width)) {
    if(e2f->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e2f->colliding = 1;
     e2f->cd = -2;
     playerHealth--;
    }
   } else {
    e2f->colliding = 0;
   }
  }

  if(p->punching == 0 && p->flipped == 1) {
   if((e2f->active) && (e2f->col == p->col + p->width)) {
    if(e2f->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e2f->colliding = 1;
     e2f->cd = -2;
     playerHealth--;
    }
   } else {
    e2f->colliding = 0;
   }
  }

  if(p->punching == 1 && p->flipped == 1) {
   if((e2f->active) && (e2f->col == p->col + p->width)) {
    if(e2f->colliding == 0) {
     playSoundB(oofSound, 6632, 11025, 0);
     e2f->colliding = 1;
     e2f->cd = -2;
     playerHealth--;
    }
   } else {
    e2f->colliding = 0;
   }
  }

  if (p->punching == 1 && p->flipped == 0) {
    if((e2f->active) && (e2f->col == p->col + p->width)) {
     if(e2f->colliding == 0) {
      e2f->dead = 20;
      enemiesDead++;
      e2f->active = 0;
      e2f->colliding = 1;

     }
    } else {
     e2f->colliding = 0;
   }
  }

  if(playerHealth == 0) {
   goToLose3();
  }

  if(enemiesDead == 10) {
   goToFinalCutScene();
  }
 }

 void enemy3PlayerCollisionCheck(ENEMIES * e3, PLAYER * p) {

  if(p->flipped == 0) {
   if((e3->col + e3->width == p->col)
    && (e3->row + e3->height >= p->row)
    && (e3->row <= p->row + p->height)) {
    playSoundB(oofSound, 6632, 11025, 0);
    playerHealth--;
   }
   if((e3->col == p->col + p->width)
    && (e3->row + e3->height >= p->row)
    && (e3->row <= p->row + p->height)) {
    playSoundB(oofSound, 6632, 11025, 0);
    playerHealth--;
   }
   if((e3->row == p->row + p->height)
    && (e3->col + e3->width >= p->col)
    && (e3->col <= p->col + p->width)) {
    playSoundB(oofSound, 6632, 11025, 0);
    playerHealth--;
   }
  }

  if(p->flipped == 1) {
   if((e3->col + e3->width == p->col)
    && (e3->row + e3->height >= p->row)
    && (e3->row <= p->row + p->height)) {
    playSoundB(oofSound, 6632, 11025, 0);
    playerHealth--;
   }
   if((e3->col == p->col + p->width)
    && (e3->row + e3->height >= p->row)
    && (e3->row <= p->row + p->height)) {
    playSoundB(oofSound, 6632, 11025, 0);
    playerHealth--;
   }
   if((e3->row == p->row + p->height)
    && (e3->col + e3->width >= p->col)
    && (e3->col <= p->col + p->width)) {
    playSoundB(oofSound, 6632, 11025, 0);
    playerHealth--;
   }
  }

  if(playerHealth == 0) {
   goToLose1();
  }
 }



 void enemy4PlayerCollisionCheck(ENEMIES * e4, PLAYER * p) {

  if(p->punching == 0 && p->flipped == 0) {
   if((e4->active) && (e4->col + e4-> width >= p->col)
    &&(e4->col <= p->col + p->width)
    &&(e4->row + e4->height == p->row)) {
    playSoundB(oofSound, 6632, 11025, 0);
    playerHealth--;
   }
  }

  if(p->punching == 0 && p->flipped == 1) {
   if((e4->active) && (e4->col + e4-> width >= p->col)
    &&(e4->col <= p->col + p->width)
    &&(e4->row + e4->height == p->row)) {
    playSoundB(oofSound, 6632, 11025, 0);
    playerHealth--;
   }
  }

  if(p->punching == 1 && p->flipped == 1) {
   if((e4->active) && (e4->col + e4-> width >= p->col)
    &&(e4->col <= p->col + p->width)
    &&(e4->row + e4->height == p->row)) {
    playSoundB(oofSound, 6632, 11025, 0);
    playerHealth--;
   }
  }

  if(playerHealth == 0) {
   goToLose3();
  }
 }


 void parachutePlayerCollisionCheck(PARACHUTE * ch, PLAYER * p) {

  if(p->flipped == 0) {
   if((ch->col + ch->width == p->col)
    && (ch->row + ch->height >= p->row)
    && (ch->row <= p->row + p->height)) {
    goToL2Instructs();
   }

   if((ch->col == p->col + p->width)
    && (ch->row + ch->height >= p->row)
    && (ch->row <= p->row + p->height)) {
    goToL2Instructs();
   }

   if((ch->row == p->row + p->height)
    && (ch->col + ch->width >= p->col)
    && (ch->col <= p->col + p->width)) {
    goToL2Instructs();
   }
  }

  if(p->flipped == 1) {
   if((ch->col + ch->width == p->col)
    && (ch->row + ch->height >= p->row)
    && (ch->row <= p->row + p->height)) {
    goToL2Instructs();
   }

   if((ch->col == p->col + p->width)
    && (ch->row + ch->height >= p->row)
    && (ch->row <= p->row + p->height)) {
    goToL2Instructs();
   }

   if((ch->row == p->row + p->height)
    && (ch->col + ch->width >= p->col)
    && (ch->col <= p->col + p->width)) {
    goToL2Instructs();
   }
  }
 }






 void setupSounds() {
     *(volatile u16 *)0x04000084 = (1<<7);

  *(volatile u16*)0x04000082 = (1<<1) |
                      (1<<2) |
                      (3<<8) |
                      0 |
                      (1<<11) |
                      (1<<3) |
                      (3<<12) |
                      (1<<14) |
                      (1<<15);

  *(u16*)0x04000080 = 0;
 }

 void playSoundA( const unsigned char* sound, int length, int frequency, int loops) {
         dma[1].cnt = 0;

         int ticks = (16777216)/frequency;

         DMANow(1, sound, (void* )0x040000A0, (2 << 21) | (3 << 28) | (1 << 25) | (1 << 26));

         *(volatile unsigned short*)0x4000102 = 0;

         *(volatile unsigned short*)0x4000100 = -ticks;
         *(volatile unsigned short*)0x4000102 = (1<<7);


      soundA.data = sound;
      soundA.length = length;
      soundA.frequency = frequency;
      soundA.isPlaying = 1;
      soundA.loops = loops;
      soundA.duration = ((59.727)*length)/frequency;
      soundA.vbCount = 0;


 }


 void playSoundB( const unsigned char* sound, int length, int frequency, int loops) {

         dma[2].cnt = 0;

         int ticks = (16777216)/frequency;

         DMANow(2, sound, (void* )0x040000A4, (2 << 21) | (3 << 28) | (1 << 25) | (1 << 26));

         *(volatile unsigned short*)0x4000106 = 0;

         *(volatile unsigned short*)0x4000104 = -ticks;
         *(volatile unsigned short*)0x4000106 = (1<<7);

         soundB.data = sound;
      soundB.length = length;
      soundB.frequency = frequency;
      soundB.isPlaying = 1;
      soundB.loops = loops;
      soundB.duration = ((59.727)*length)/frequency;
      soundB.vbCount = 0;

 }

 void pauseSound() {


  *(volatile unsigned short*)0x4000102 = 0;
  *(volatile unsigned short*)0x4000106 = 0;

  soundA.isPlaying = 0;
  soundB.isPlaying = 0;

 }

 void unpauseSound() {


  *(volatile unsigned short*)0x4000102 = (1<<7);
  *(volatile unsigned short*)0x4000106 = (1<<7);

  soundA.isPlaying = 1;
  soundB.isPlaying = 1;

 }

 void stopSound() {

     dma[1].cnt = 0;
     dma[2].cnt = 0;

     *(volatile unsigned short*)0x4000102 = 0;
  *(volatile unsigned short*)0x4000106 = 0;

  soundA.isPlaying = 0;
  soundB.isPlaying = 0;

 }

 void setupInterrupts()
 {
  *(unsigned short*)0x4000208 = 0;

  *(unsigned int*)0x3007FFC = (unsigned int)interruptHandler;

  *(unsigned short*)0x4000200 |= 1 << 0;
  *(unsigned short*)0x4000004 |= 1 << 3;
  *(unsigned short*)0x4000208 = 1;
 }

 void interruptHandler() {
  *(unsigned short*)0x4000208 = 0;
  if(*(volatile unsigned short*)0x4000202 & 1 << 0) {

   if(soundA.isPlaying) {
    soundA.vbCount++;
    if(soundA.vbCount > soundA.duration) {
     if(soundA.loops) {
      playSoundA(soundA.data, soundA.length, soundA.frequency, soundA.loops);
     } else {
      dma[1].cnt = 0;
      soundA.isPlaying = 0;
      *(volatile unsigned short*)0x4000102 = 0;
     }
    }
   }

   if(soundB.isPlaying) {
    soundB.vbCount++;
    if(soundB.vbCount > soundB.duration) {
     if(soundB.loops) {
      playSoundB(soundB.data, soundB.length, soundB.frequency, soundB.loops);
     } else {
      dma[2].cnt = 0;
      soundB.isPlaying = 0;
      *(volatile unsigned short*)0x4000106 = 0;
     }
    }
   }

   *(volatile unsigned short*)0x4000202 = 1 << 0;
  }

  *(unsigned short*)0x4000208 = 1;
 }
